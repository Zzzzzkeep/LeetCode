# No8 不同路径II

**题目表述**

一个机器人位于一个$m \times n$网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图到达网格的右下角。先考虑网格中有障碍物，那么从左上角到右下角将会有多少条不同的路径?

**示例1：**

~~~java
输入：
    [
    	[0,0,0],
    	[0,1,0],
    	[0,0,0]
	]
输出： 2
解释：
3*3网格的正中间有一个障碍物。
从左上角到右下角一共有两条不同的途径：
    1. 向右——向右——向下——向下
    2. 向下——向下——向右——向右
~~~

**说明：**

$m$和$n$的值均不超过100。

**方法一：动态规划**

**思路及算法**

我们用$pd[i][j]$表示从坐标原点$(0,0)$到坐标$(i,j)$的路径总数，$u(i,j)$表示坐标$(i,j)$是否可行，如果坐标$(i,j)$有障碍物，$u(i,j)=1$，否者$u(i,j)=0$。

因为机器人每次只能向下或者向右移动一步，因此从坐标$(0,0)$到坐标$(i,j)$的路径总数的值只取决于坐标$(0,0)$到$(i,j-1)$的路径总数和坐标$(0,0)$到坐标$(i-1,j)$的路径总数，即$pd[i][j]$只能通过$pd[i][j-1]$和$pd[i-1][j]$转移得到。

当坐标$(i,j)$本身有障碍的时候，任何路径都到不了$(i,j)$，此时$pd[i][j]=0$。综上所述，我们可以得到这样动态规则转移方程：
$$
pd[i][j]=
\begin{cases}
0,&u(i,j)=1 \\
pd[i-1][j]+pd[i][j-1],&u(i,j) \ne 0
\end{cases}
$$
**滚动数组**

滚动数组思想是一种常见的动态规划优化方法，在我们的题目中已经多次用到，例如**剑指Offer 46.把数字翻译成字符串**、**70.爬楼梯**等，当我们定义的状态在动态规划的转移方程中之和某几个状态相关的时候，就可以考虑这种优化方法，目的是给空间复杂度**降维**。

**代码示例1**

~~~~java
public int nuiquePathWithObstacles(int[][] obstacleGrid){
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    //创建动态规划数组
    int[][] dp = new int[m+1][n+1];
    //初始化状态
    pd[0][1] = 1;
    //动态规划
    for(int i = 1;i<=m;i++){
        for(int j = 1;j<=n;j++){
            if(obstacleGrid[i-1][j-1]==1){
                dp[i][j]=0;
            }else{
                dp[i][j] = dp[i-1][j]+dp[i][j-1]; 
            }
        }
    }
    return pd[m][n];
}
~~~~

