# No3 有序矩阵中第K小的元素

**题目表述**

给定一个$n \times n$矩阵$matrix$，其中每行和每列元素均按升序排序排序，找到矩阵中第$k$小的元素。请注意，它是排序后的第$k$小元素，而不是第$k$个不同的元素。

**示例**

**来源**

LeetCode 378

**提示**

你可以假设$k$的值永远是有效的，$1 \le k \le n^2$。

**方法一：二分查找**

**思路及算法**

1. 已知$matrix[0][0]$是整个矩阵的最小值，$matrix[n-1][n-1]$是整个矩阵的最大值。

   ~~~java
   int n = maxtrix.length;
   int left = maxtrix[0][0];
   int right = maxtrix[n-1][n-1];
   ~~~

2. 二分查找精髓在于取**中间值**

   ~~~java
   int mid = left + (left + right)/2;
   ~~~

   利用中间值$mid$将矩阵切分成两部分，矩阵的左边的元素小于等于$mid$，矩阵右边的元素大于$mid$。

3. 切割后矩阵左边元素个数记为$num$，则有

   ~~~java
   int num = 0;
   if(num >= k){ //如果左边元素个数大于k，说明第k小的元素在左边
       right = mid;//右边界往左移
   }else{
       left = mid + 1;//左边界往右移
   }
   ~~~

   然后根据步骤2重新计算中间值。

4. 计算切割后矩阵左边元素的个数$num$,可以这样描述走法：

   1. 初始位置在$matrix[n-1][0]$（即左下角）；
   2. 设当前位置$matrix[i][j]$。若$matrix[i][j] \le mid$，则将当前在所列的不大于$mid$的数的数量（$i+1$）累加到$num$中，并向右移动，否则向上移动。
   3. 不断移动直到走出格子。

   ~~~java
   int i = n-1;
   int j = 0;
   while(i>=0&&j<n){
       if(matrix[i][j]<=mid){
           num += i+1;
           j++;
       }else{
           i--;
       }
   }
   ~~~

   

   我们发现这样的走法时间复杂度为$O(n)$，即我们可以线性的计算对于任意一个$mid$，矩阵中有多少个不大于它的数。这满足二分查找的性质。

   